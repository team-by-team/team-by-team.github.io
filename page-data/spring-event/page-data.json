{"componentChunkName":"component---src-templates-post-jsx","path":"/spring-event/","result":{"data":{"site":{"siteMetadata":{"title":"TEAM-BY-TEAM"}},"markdownRemark":{"id":"0bf82b69-7aee-5aa6-bb7e-8d973d2bc283","excerpt":"해당 글은 우아한테크코스 5기 팀바팀 크루 성하가 작성했습니다!! 프로젝트를 진행하던 중 스프링 이벤트를 사용하게 되었습니다! 왜 스프링 이벤트를 사용했는지, 어떻게 사용하는지, 사용 시 고려할 점 등에 대해 자세히 알아보도록 하겠습니다! 0. 스프링 이벤트 도입 배경    프로젝트를 진행하면서 다음과 같은 요구사항이 존재했습니다. 팀 캘린더의 일정이 등…","html":"<blockquote>\n<p>해당 글은 우아한테크코스 5기 팀바팀 크루 <a href=\"https://github.com/sh111-coder\">성하</a>가 작성했습니다!!</p>\n</blockquote>\n<br>\n<p>프로젝트를 진행하던 중 스프링 이벤트를 사용하게 되었습니다!</p>\n<p>왜 스프링 이벤트를 사용했는지, 어떻게 사용하는지, 사용 시 고려할 점 등에 대해 자세히 알아보도록 하겠습니다!</p>\n<hr>\n<h2>0. 스프링 이벤트 도입 배경</h2>\n<p>   프로젝트를 진행하면서 다음과 같은 요구사항이 존재했습니다.</p>\n<blockquote>\n<p>팀 캘린더의 일정이 등록, 수정, 삭제되면 팀 피드에 일정 알림이 생성된다.</p>\n</blockquote>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/d6ff41f936fbb39b3ffebd062b92a742/f6909/img.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 25.882352941176467%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGUlEQVR42kWO2XKCQBBF/f9vyuqCqFFjYlRAQAFZBEGSMuXKSTtalYdbPdPd9/apReEeb3HGX56lnlj5FcN+yOvLhGbd4PlxzOAtoK3ZtBomTw+faE0L29oReBfxnZTXl4wsO1JL0yPR6kIc3hVdWLo7HPsbZ35VKYdu/2t/bm1xnR/xnP49dxWFBCaxBAaQhBCvKtIYxqNEKEw6baGSOv5I6Oou/Z5Hoz6l11nguYebJ6zEB2FQkecHapvsgD0vMI0Uy8iwzEyoCiZfEbNpwnQSyzwXwkLNzNla7bpOqWSZG6HOCfxfylII1/FeXdSaBu2WidYyGA1D9e7qjuoP+z7vgxUd3ZZdR2nQ9+h1XTXXNQtjWlBuj/wBEJFqDFdKmPgAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='일정 알림 디자인' title='' src='/static/d6ff41f936fbb39b3ffebd062b92a742/ca1dc/img.png' srcset='/static/d6ff41f936fbb39b3ffebd062b92a742/e7570/img.png 170w,\n/static/d6ff41f936fbb39b3ffebd062b92a742/f46e7/img.png 340w,\n/static/d6ff41f936fbb39b3ffebd062b92a742/ca1dc/img.png 680w,\n/static/d6ff41f936fbb39b3ffebd062b92a742/02d09/img.png 1020w,\n/static/d6ff41f936fbb39b3ffebd062b92a742/f6909/img.png 1181w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>일정 알림 디자인</figcaption>\n  </figure></p>\n<p>위의 디자인처럼 팀 피드 공간에 팀 캘린더의 일정이 등록, 수정, 삭제되면 알림이 생성되도록 하는 요구사항이었습니다.</p>\n<p>(여기서 알림은 실시간 알림이 아니라 게시글처럼 생성되는 알림을 의미합니다.)</p>\n<br>\n<p>스프린트를 거쳐서 팀 캘린더의 일정 등록, 수정, 삭제 로직은 구현되어 있는 상태였으므로</p>\n<p>처음에는 단순하게 일정 알림 기능을 추가하면 된다고 생각해서 팀 캘린더 서비스에 다음과 같이 로직을 추가했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@RequiredArgsConstructor</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TeamCalendarScheduleService</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ScheduleRepository</span> scheduleRepository<span class=\"token punctuation\">;</span>\n\t\n    <span class=\"token comment\">// 일정 알림 Service 의존성 추가</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">NotificationService</span> notificationService<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Long</span> <span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 기존 일정 등록 로직</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        \n        <span class=\"token comment\">// 일정 알림 생성 로직 추가</span>\n        notificationService<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 기존 일정 수정 로직</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        \n        <span class=\"token comment\">// 일정 알림 생성 로직 추가</span>\n        notificationService<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 기존 일정 삭제 로직</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        \n        <span class=\"token comment\">// 일정 알림 생성 로직 추가</span>\n        notificationService<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>알림 생성 로직을 추가하고 생각을 해보았을 때 다음과 같은 문제가 생겼습니다.</p>\n<ul>\n<li><strong>Schedule과 Notification 도메인 간의 강한 결합도</strong></li>\n<li><strong>TeamCalendarScheduleService의 단일 책임 원칙(SRP) 위반</strong></li>\n</ul>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/9adc736b5aa82741d603c4a39a7147f1/5745f/img_1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 34.705882352941174%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABEUlEQVR42oWRe0uDYBSH/f7fpoKKikEE9cdYEVsLb3Pq5taFvExfNT3n13k1iM0i4eGHB3w8F4NLBVbFEKmDGYePrqgGyD+HFIJB0RIUuqDVok9N4IAiX76mgZDEuMwAMwbsBLCSPvX7ItXCjY9WBI0Wrb0f8Sb4R0gwP1qBRMiwYu6FeFkhGN/i4eoM09EFxucnyKwZeBuiVApVVe2hygr2e43LiYWj6wlO76Y4vrnH6NGFJz8yWDqpfQvKM1G4z8idORrf7jqktgER7dG0JB0ynt5qzF+rjtlWSda9kCIPHDpgGbVjrUcWoez2t6Pokb30e4eSVtqnKXt09chc7MB5NqTI/7zyTq4Z10ByQCr1L5TGFtWIDFazAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='Schdule - Notification 의존' title='' src='/static/9adc736b5aa82741d603c4a39a7147f1/ca1dc/img_1.png' srcset='/static/9adc736b5aa82741d603c4a39a7147f1/e7570/img_1.png 170w,\n/static/9adc736b5aa82741d603c4a39a7147f1/f46e7/img_1.png 340w,\n/static/9adc736b5aa82741d603c4a39a7147f1/ca1dc/img_1.png 680w,\n/static/9adc736b5aa82741d603c4a39a7147f1/02d09/img_1.png 1020w,\n/static/9adc736b5aa82741d603c4a39a7147f1/5745f/img_1.png 1258w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>Schdule - Notification 의존</figcaption>\n  </figure></p>\n<br>\n<h3>0-1. Schedule과 Notification 도메인 간의 강한 결합도</h3>\n<p>먼저, Schedule 로직에 Notification 도메인 생성 로직이 존재하기 때문에 Schedule과 Notification이 강한 결합을 가지게 되었습니다.</p>\n<p>두 개의 도메인이 라이프 사이클이 비슷하거나 동일한 제약 사항을 공유한다면 결합을 가져도 괜찮다고 생각하지만,</p>\n<p>Schedule과 Notification 도메인은 라이프 사이클이 비슷하지 않고, 동일한 제약 사항도 공유하지 않습니다.</p>\n<p>이러한 상황에서 이후에 Notification의 생성 로직이 변경된다면 Schedule의 등록, 수정, 삭제 로직에 직접적인 영향을 미치게 될 것입니다.</p>\n<p><strong>따라서 서로 다른 두 도메인이 강한 결합도를 가져서 재사용성과 유지보수성이 떨어지게 됐습니다.</strong></p>\n<br>\n<h3>0-2. TeamCalendarScheduleService의 단일 책임 원칙(SRP) 위반</h3>\n<p>다음으로 ScheduleService의 단일 책임 원칙이 위반되었다고 생각했습니다.</p>\n<p>현재 구조에서는 ScheduleService, 즉 Schedule이 Notification을 생성하는 책임을 가지게 됩니다.</p>\n<p>일정의 입장에서 알림에 대해서는 알 필요가 없다고 생각했기 때문에</p>\n<p>Schdule -> Notification의 의존성을 없애는 것이 좋다고 생각하게 되었습니다.</p>\n<br>\n<p>위의 2가지 이유로 의존성을 없앨 수 있는 방법에 대해서 생각해보게 되었고,</p>\n<p>이전에 도메인 간의 의존성을 없앨 수 있는 방법인 스프링 이벤트에 대해 들어보았기 때문에 적용을 해보기로 했습니다!</p>\n<hr>\n<h2>1. 스프링 이벤트를 사용해서 의존성 분리하기</h2>\n<p>   어떻게 스프링 이벤트를 사용하면 도메인 의존성을 분리할 수 있을까요?</p>\n<p>그림으로 요약해서 도식화해보면 다음과 같습니다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/a9bd639441020e8e8342c3f1e9596a3e/cc6c5/img_2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 21.176470588235293%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA5klEQVR42jWQjUrDMBSF9/7PIfgC4gso8wepW4XhhpYJUrslXdr1Z02b5PM26IVDTg7knnOyCO2ZUCkQhE444B1cDNga+vnsiTNME0XXUPQtjR2iNnpoJ4G8scIXoTxwSB45rp5wZYEqNX07kO960uWebG1otOOkFXt95Dp54Or5jrefb4xoqhlYfijutwX6ElhgFGazigiVxktGL475rmOb5HymJZ0R6+DRkuz2PeVm80pWlVLFS9JA8nXiJVNUdk44WsIo8aVCmGysEaS3ExpksR+JBv96NJy/Zb78TV2fMabCOc8vVTow6Fhr32QAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='스프링 이벤트 구조' title='' src='/static/a9bd639441020e8e8342c3f1e9596a3e/ca1dc/img_2.png' srcset='/static/a9bd639441020e8e8342c3f1e9596a3e/e7570/img_2.png 170w,\n/static/a9bd639441020e8e8342c3f1e9596a3e/f46e7/img_2.png 340w,\n/static/a9bd639441020e8e8342c3f1e9596a3e/ca1dc/img_2.png 680w,\n/static/a9bd639441020e8e8342c3f1e9596a3e/02d09/img_2.png 1020w,\n/static/a9bd639441020e8e8342c3f1e9596a3e/9d567/img_2.png 1360w,\n/static/a9bd639441020e8e8342c3f1e9596a3e/cc6c5/img_2.png 1552w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>스프링 이벤트 구조</figcaption>\n  </figure></p>\n<p>ScheduleService와 NotificationService 간의 의존성을 위와 같이 Event를 통해 해결할 수 있습니다.</p>\n<p>ScheduleService에서 일정이 등록, 수정, 삭제되면 NotificationService의 알림 생성 로직을 실행하는 것이 아니라,</p>\n<p>ScheduleEvent를 발행하기만 하고, ScheduleEvent가 발행되면 NotificationService에서 알림 생성 로직을 실행합니다.</p>\n<p><strong>이를 통해 Schedule이 Notification을 의존하는 문제를 해결할 수 있었고,</strong></p>\n<p><strong>ScheduleService에서는 Notification의 로직을 알 필요 없이 이벤트만 발행하면 되었습니다.</strong></p>\n<br>\n<h3>✅ ApplicationEventPublisher</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@FunctionalInterface</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ApplicationEventPublisher</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token keyword\">default</span> <span class=\"token keyword\">void</span> <span class=\"token function\">publishEvent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ApplicationEvent</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">publishEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span> event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">publishEvent</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> event<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>이벤트를 발행할 곳에서 ApplicationEventPublisher의 publishEvent()를 통해서 이벤트를 발행할 수 있습니다.</strong></p>\n<p>스프링 4.2 이전에는 default 메소드밖에 없어서 Event 객체를 사용하려면 ApplicationEvent를 상속해야 했습니다.</p>\n<p>하지만 스프링 4.2 이후에는 일반 Object를 파라미터로 받는 publishEvent()가 추가되어</p>\n<p>일반 객체로도 이벤트를 생성할 수 있게 되었습니다.</p>\n<br>\n<h3>✅  @EventListener</h3>\n<p><strong>이벤트가 발행되면, @EventListener 어노테이션이 선언된 메소드에서 이벤트를 Listen해서 실행하게 됩니다.</strong></p>\n<p><strong>해당 메소드에서 발행 시에 파라미터로 넘겨준 Event 객체를 전달하여 로직에 사용할 수 있습니다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@EventListener</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">executeEvent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">Event</span> event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>간단하게 스프링의 이벤트 발행 - 실행 Flow를 요약하면 다음과 같습니다.</p>\n<ol>\n<li>ApplicationEventPublisher가 publishEvent()로 이벤트 발행</li>\n<li>ApplicationContext가 발행된 이벤트를 @EventListener가 붙어있는 메소드에 전달</li>\n<li>@EventListener 메소드 로직 실행</li>\n</ol>\n<p>2번 과정을 살펴보면, ApplicationContext가 등장하게 됩니다.</p>\n<p>ApplicationContext 클래스를 들어가보면, 다음과 같이 ApplicationEventPublisher를 상속받고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ApplicationContext</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ApplicationEventPublisher</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>따라서, 스프링이 실행되어 ApplicationContext가 로드됐을 때</p>\n<p>이벤트가 발행되면 ApplicationContext에서 @EventListener의 메소드를 실행하게 됩니다.</p>\n<br>\n<p>이렇게 스프링 이벤트의 이론적인 부분을 알아봤습니다!</p>\n<p>그렇다면 구체적으로 스프링 이벤트를 사용하여 리팩토링한 코드를 살펴봅시다!</p>\n<hr>\n<h2>2.  스프링 이벤트를 사용해서 기존 코드 리팩토링</h2>\n<br>\n<h3>✅ ScheduleService</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@RequiredArgsConstructor</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TeamCalendarScheduleService</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ScheduleRepository</span> scheduleRepository<span class=\"token punctuation\">;</span>\n\t\n    <span class=\"token comment\">// ApplicationEventPublisher 추가</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ApplicationEventPublisher</span> eventPublisher<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Long</span> <span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 기존 일정 등록 로직</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        \n        <span class=\"token comment\">// ScheduleCreateEvent 발행 로직 추가</span>\n        eventPublisher<span class=\"token punctuation\">.</span><span class=\"token function\">publishEvent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ScheduleCreateEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 기존 일정 수정 로직</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        \n        <span class=\"token comment\">// ScheduleUpdateEvent 발행 로직 추가</span>\n        eventPublisher<span class=\"token punctuation\">.</span><span class=\"token function\">publishEvent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ScheduleCreateEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 기존 일정 삭제 로직</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        \n        <span class=\"token comment\">// ScheduleDeleteEvent 발행 로직 추가</span>\n        eventPublisher<span class=\"token punctuation\">.</span><span class=\"token function\">publishEvent</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ScheduleCreateEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>ScheduleService에서 NotificationService가 아닌</p>\n<p>이벤트 발행 객체 ApplicationEventPublisher를 사용해서 각 로직마다 이벤트를 발행해줬습니다.</p>\n<br>\n<h3>✅ ScheduleEvent</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ScheduleEvent</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Long</span> scheduleId<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Long</span> teamPlaceId<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Title</span> title<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Span</span> span<span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>발행하는 ScheduleEvent는 NotificationService에서 알림 생성 시 필요한 정보만 담아서 구현했습니다.</p>\n<br>\n<h3>✅ NotificationService</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@RequiredArgsConstructor</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NotificationService</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">NotificationRepository</span> notificationRepository<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Transactional</span><span class=\"token punctuation\">(</span>propagation <span class=\"token operator\">=</span> <span class=\"token class-name\">Propagation</span><span class=\"token punctuation\">.</span><span class=\"token constant\">REQUIRES_NEW</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@TransactionalEventListener</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">createScheduleNotification</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">ScheduleEvent</span> scheduleEvent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>NotificationService에서는 Event를 받아서 로직을 실행하기 위해</p>\n<p>@EventListener를 사용하여 이벤트가 발행되면 ApplicationContext에서 해당 메소드를 실행하도록 설정했습니다.</p>\n<p>(왜 @EventListener가 아닌 @TransactionalEventListener를 사용했는지와</p>\n<p>@Transactional의 propagation을 설정한 이유는 아래에서 설명하도록 하겠습니다!)</p>\n<hr>\n<h2>3.  스프링 이벤트 사용 시 고려할 점</h2>\n<p>위처럼 생각보다는 간단하게 코드 리팩토링을 진행할 수 있었습니다.</p>\n<p>하지만, 간단했던 코드 구현과는 달리 스프링 이벤트를 사용할 때는 고려할 점이 많았습니다!</p>\n<p>이번 프로젝트의 스프링 이벤트를 사용할 때 고려했던 점들을 나열해보도록 하겠습니다.</p>\n<br>\n<h3>3-1. Event 발행 후에 EventListener 로직을 바로 실행해도 되는가? (@TransactionalEventListener)</h3>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/ac48d037243e633aab1b34f543e419b1/ca38a/img_3.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 36.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA9klEQVR42pWRW2uDQBCF/f//xVeffCgtgYLQFBofhQStN9SoWRPd28nOphtsINAODLvM7J795qwHE8uyII5j7HZf+Nx+oGkaKkNrjf+G5zb7Q4a3zTteXjc4XziU0lbwr/lLUEqFyYhwZWilxiwAtYLjnJsz8imVEMKeuQvO84wi/8Y0MRyPHXqTXdehbVsMw4A8z1HXNfq+t/V1Uo0sGsfxJsjYyTaKorSrMCRSKTOysqOQv2maoixLS6l+ei6JLssyVFV1E0ySBEEQwPd9RFF0/wznC1FSPwxDO8njZ9F+fdejFxw60TwGUTDGjB3TUw+p5zy8AnirHIIPk1N+AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='@EventListener 실행 시점' title='' src='/static/ac48d037243e633aab1b34f543e419b1/ca1dc/img_3.png' srcset='/static/ac48d037243e633aab1b34f543e419b1/e7570/img_3.png 170w,\n/static/ac48d037243e633aab1b34f543e419b1/f46e7/img_3.png 340w,\n/static/ac48d037243e633aab1b34f543e419b1/ca1dc/img_3.png 680w,\n/static/ac48d037243e633aab1b34f543e419b1/ca38a/img_3.png 871w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>@EventListener 실행 시점</figcaption>\n  </figure></p>\n<p>@EventListener를 사용한다면, 이벤트가 발행되는 시점에 바로 EventListener의 로직이 실행되게 됩니다.</p>\n<p>따로 EventListener의 로직 실행 시점을 특정해서 설정할 수 없습니다.</p>\n<p>이때 문제가 되는 것은, EventListener의 로직에서 예외가 발생했을 때의 상황입니다.</p>\n<p>예외가 발생하게 되면 트랜잭션이 롤백이 되는데 아래의 상황을 살펴봅시다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/c2e6a8307a11cee83c437f2885388595/24c26/img_4.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 35.88235294117647%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABPElEQVR42oVR22qDUBD0/0s/I68lfTAQyGOh0FQkbYNRG23ihaoxXpMeb5me3WCfWrqwzDnrnNkZVCDrcrngY+fDtLewty4cd4fV6xpZ/QU8PgDGG3Al4r9SxkMQV3jSTTyvbGgv71hbHlIBiNsbdPd36Eiv63j5X/0j2DQtypOA631i58cSIxyyEqIFUuny1AN1A/T9ACHEr85oPgzDVfB4PCIIAlRVhSzLuIs8RxiGsCwTeZ7hkCR8t22bv0dRhDiOGdM0hed56GQChZRJkJoEm6bhrusaRVHIR4k8n9C2MkVZ8uLz+Szd9jwjpLvv+4yKpmmYz+eYTqfQdR3jT3JdF4vFAqqqYrlc8oy4s9kMhmEwj8SoyN1kMmFUaOtms4FpmuxwLCLv93sZ2WJnVBSPeBR5XDxyHcdh/AZCexEWoVGrCQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='EventListener 로직 롤백' title='' src='/static/c2e6a8307a11cee83c437f2885388595/ca1dc/img_4.png' srcset='/static/c2e6a8307a11cee83c437f2885388595/e7570/img_4.png 170w,\n/static/c2e6a8307a11cee83c437f2885388595/f46e7/img_4.png 340w,\n/static/c2e6a8307a11cee83c437f2885388595/ca1dc/img_4.png 680w,\n/static/c2e6a8307a11cee83c437f2885388595/24c26/img_4.png 921w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>EventListener 로직 롤백</figcaption>\n  </figure></p>\n<p>순서대로 살펴봅시다.</p>\n<ol>\n<li>일정 등록되어 이벤트 발행</li>\n<li>이벤트가 발행되어 EventListener 로직 실행</li>\n<li>일정 등록 메소드 안에서 다른 로직 수행</li>\n<li>일정 등록 메소드가 종료되기 전 (Commit 되기 전) EventListener에서 예외가 발생하여 롤백</li>\n</ol>\n<p>이 경우는 EventListener 로직인 일정 알림 로직에 예외가 발생하여 롤백이 된 경우입니다.</p>\n<p>이때 일정 등록이 Commit이 되지 않았기 때문에 일정 알림 로직에 예외가 발생해서 롤백이 되는 건데</p>\n<p>일정 등록 로직까지 롤백이 되는 상황이 발생합니다.</p>\n<p>만약 해당 상황이 정상적인 경우는 그대로 @EventListener를 사용해도 되지만,</p>\n<p>저희 프로젝트에서는 일정 알림의 예외로 인해 일정의 등록, 수정, 삭제가 롤백되는 것은 비정상적인 상황으로 봤기 때문에</p>\n<p>다른 해결책을 찾게 되었습니다.</p>\n<br>\n<h3>※ @TransactionalEventListener</h3>\n<p>이 상황을 해결할 수 있는 것이 바로 @TransactionalEventListener입니다.</p>\n<p>위에서 언급했듯이 @EventListener를 사용할 때는 EventListener의 실행 시점을 지정할 수 없었습니다.</p>\n<p>@EventListener 대신 @TransactionalEventListener를 사용하면 트랜잭션 기준으로 실행 시점을 정할 수 있습니다.</p>\n<p>@TransactionalEventListener에서 phase 속성을 지정하면 실행 시점을 변경할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. BEFORE_COMMIT: 이벤트 발행 로직이 커밋되기 전에 실행\n2. AFTER_COMMIT : 이벤트 발행 로직이 커밋된 후에 실행 (기본값)\n3. AFTER_ROLLBACK : 이벤트 발행 로직이 롤백된 후에 실행\n4. AFTER_COMPLETION : 이벤트 발행 로직이 커밋 or 롤백된 후에 실행</code></pre></div>\n<p>4가지 옵션으로 실행 시점을 변경할 수 있습니다.</p>\n<p>위의 상황을 방지하기 위해서는 일정 등록, 수정, 삭제 로직이 커밋된 후에 일정 알림 로직이 실행되어야 합니다.</p>\n<p>이렇게 설정을 하면 일정 알림 로직에서 예외가 발생하여 롤백이 되어도 일정 등록, 수정, 삭제는 이미 커밋이 되었으므로</p>\n<p>데이터가 롤백되지 않을 것입니다.</p>\n<p>따라서 프로젝트에서는 @TransactionalEventListener의 기본값인 AFTER_COMMIT를 사용했습니다!</p>\n<br>\n<h3>3-2. @TransactionalEventListener를 사용한 상황에서, 데이터를 쓰는 로직이 있는가?</h3>\n<p>@TransactionalEventListener를 사용할 때 AFTER_COMMIT 옵션을 사용하면 다음과 같은 상황이 됩니다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/81d40812df03710b24cad472912dc393/68327/img_5.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 29.411764705882355%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7ElEQVR42m1QSY6DMBDk/w/hChduvIAbt1GUMMNqVhsIAxgEFdxkmCDRUrm77XL1ouFt67peQpmoW3zd7rg/vvH4CShOWI6V/i0nrqaOaZoIV6bueTsgrTpk1S9y0YMVLflp2TnLsmIYhn/BpmkQhiH5oigIeZ5DCAHf98GSBM+2geDVDsHJK15ZlsSN43gX7PsenHNkWYa6riGlPDoexxHJJpam6eleyg3veJ5nKhxFEeWa67qwLAuGYcBxnGOfypSQaZqwbfsY6e/tM/Y8D7qukyh1GAQBJV3XnYiquhpFjfUpdLVnxti2ywUvvvbLLr9yHSYAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='@TransactionalEventListener AFTER_COMMIT 사용 상황' title='' src='/static/81d40812df03710b24cad472912dc393/ca1dc/img_5.png' srcset='/static/81d40812df03710b24cad472912dc393/e7570/img_5.png 170w,\n/static/81d40812df03710b24cad472912dc393/f46e7/img_5.png 340w,\n/static/81d40812df03710b24cad472912dc393/ca1dc/img_5.png 680w,\n/static/81d40812df03710b24cad472912dc393/68327/img_5.png 950w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>@TransactionalEventListener AFTER_COMMIT 사용 상황</figcaption>\n  </figure></p>\n<p>일정 등록 로직이 Commit된 이후에, EventListener의 로직이 실행됩니다.</p>\n<p><strong>이때 주의해야 하는 점이 트랜잭션에서 이미 Commit이 되었기 때문에 해당 트랜잭션에서는 조회밖에 수행할 수 없습니다.</strong></p>\n<p>그래서 EventListener 로직에 데이터를 insert, update, delete하는 로직이 존재한다면 해당 로직을 반영할 수 없습니다.</p>\n<p>이때, @Transactional의 propagation을 REQUIRES_NEW로 설정하게 되면 이를 해결할 수 있습니다.</p>\n<br>\n<h3>※ @Transactional(propagation = Propagation.REQUIRES_NEW)</h3>\n<p>@Transactional의 Propagation.REQUIRES_NEW는 해당 어노테이션이 붙은 메소드 호출 시</p>\n<p>매번 새로운 트랜잭션을 시작하게 됩니다.</p>\n<p>따라서, 트랜잭션 자체가 분리되기 때문에 이후 EventListener 로직의 Commit을 수행할 수 있습니다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/a009b8280c5fc31b4ab498db75937b6c/f843c/img_6.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 48.23529411764706%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABSklEQVR42o2SS2+DMBCE+f9/JjlxSC455Vr1gRShpISAwQ6Yl6uIp6driFqlIhUrjZDs3W/HIywsqH4YcL5c4Pk+3OMJYRxDP+m1/iUVObRMMeQS4fsbmPMB//UFwj0AJd1lEpAJQAuXAa/C2AOPBD6PHrzTGSxgODgHCDozpZMr0LYLgeQs5lf4PMM5Skf5sRy/HkuQ5gVQldAE1IuAPIYSHG1VoFclOiMC9KpCTc9VaQrQ/YNDrTXqup7laRpuKUN8qeeiLHsCNk0zAQcKlDGGJEmQZRmklJNoe1aWOHkePS2fF/Xn1COEGGdHoCEXRTG67LpucqanRG63GzjnaMwLzNmMTK+ZN4aMOWuz2cC2bazX658tw/032O/3WK1WcBznYdHf2u122G63oykrDEO4rosoin6zuw+azUEQQCk1n/G9L6V4jEx9Az88AzuoxhvGAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='@Transactional(propagation = Propagation.REQUIRES_NEW)' title='' src='/static/a009b8280c5fc31b4ab498db75937b6c/ca1dc/img_6.png' srcset='/static/a009b8280c5fc31b4ab498db75937b6c/e7570/img_6.png 170w,\n/static/a009b8280c5fc31b4ab498db75937b6c/f46e7/img_6.png 340w,\n/static/a009b8280c5fc31b4ab498db75937b6c/ca1dc/img_6.png 680w,\n/static/a009b8280c5fc31b4ab498db75937b6c/f843c/img_6.png 861w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>@Transactional(propagation = Propagation.REQUIRES_NEW)</figcaption>\n  </figure></p>\n<p>저희 프로젝트에서는 EventListener 로직이 일정 알림을 생성해서 insert 하는 로직이 있었기 때문에</p>\n<p>@TransactionalEventListener와 함께 @Transactional(propagation = Propagation.REQUIRES_NEW)를 설정했습니다.</p>\n<br>\n<h3>3-3. 비동기적으로 처리해야 하는 로직인가?</h3>\n<p>스프링 이벤트 사용 시 비동기 처리도 가능합니다.</p>\n<p>EventListener 로직에 @Async로 비동기 어노테이션을 선언하고,</p>\n<p>Application에 @EnableAsync를 선언하면 비동기 처리가 가능합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Transactional</span><span class=\"token punctuation\">(</span>propagation <span class=\"token operator\">=</span> <span class=\"token class-name\">Propagation</span><span class=\"token punctuation\">.</span><span class=\"token constant\">REQUIRES_NEW</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@TransactionalEventListener</span>\n<span class=\"token annotation punctuation\">@Async</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">createScheduleNotification</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">ScheduleEvent</span> scheduleEvent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>프로젝트에서는 EventListener 로직이 일정 알림 생성으로 단순하기 때문에 따로 비동기 처리를 해주지 않았습니다.</p>\n<p>나중에 하나의 EventListener 로직에서 여러 작업을 수행한다면 고려해볼 수 있을 것 같습니다!</p>\n<hr>\n<p>지금까지 스프링 이벤트에 대해서 살펴봤습니다!</p>\n<p><strong>스프링 이벤트를 통해 도메인 의존성을 분리하고 서비스간의 결합도를 낮추는 효과를 얻을 수 있었습니다!</strong></p>\n<p>처음 사용해봤을 때 생각보다 이벤트를 발행하고 Listen해서 실행하는 구현이 간단해서 쉽다고 생각했습니다.</p>\n<p>그러나, 트랜잭션과 비동기와 관련해서 고려할 요소가 상당히 많았습니다.</p>\n<p>애플리케이션에 스프링 이벤트를 적용할 때 트랜잭션과 비동기 설정을 근거를 가지고 한다면 좋은 설계가 되지 않을까 싶습니다.</p>","frontmatter":{"title":"스프링 이벤트를 사용하여 도메인 의존성 분리하기","date":"July 31, 2023","update":"July 31, 2023","tags":["Spring","Event","도메인 의존성 분리"],"series":null},"fields":{"slug":"/spring-event/","readingTime":{"minutes":17.255}}},"seriesList":{"edges":[{"node":{"id":"9b5cdcae-47e9-5839-9ed5-77d2bb13f063","fields":{"slug":"/event-storming/"},"frontmatter":{"title":"팀바팀 이벤트 스토밍(Event Storming) 도입기"}}},{"node":{"id":"cc7a0ab1-5503-5c29-aca6-5707103b16cd","fields":{"slug":"/local-date-time-binding/"},"frontmatter":{"title":"LocalDateTime 원하는 Format으로 바인딩하기 (feat.@DateTimeFormat, @JsonFormat)"}}},{"node":{"id":"df971529-c38c-5b99-8b34-e0d1f887ad8c","fields":{"slug":"/component-styling/"},"frontmatter":{"title":"팀바팀 컴포넌트 스타일링 방법 선택"}}},{"node":{"id":"bc022be2-f94e-5294-9b49-6fba751b5bfd","fields":{"slug":"/frontend-ci/"},"frontmatter":{"title":"프론트엔드 Github Action 테스트 자동화"}}},{"node":{"id":"fb6c635b-2fb9-5625-88bb-0c70f8e7543a","fields":{"slug":"/frontend-husky/"},"frontmatter":{"title":"프론트엔드 Husky 사용해서 commit 단위로 Lint 검사"}}},{"node":{"id":"dde0edaf-b006-51f0-a50e-f47285556fc0","fields":{"slug":"/react-query-reason/"},"frontmatter":{"title":"팀바팀 React query 도입이유"}}},{"node":{"id":"0bf82b69-7aee-5aa6-bb7e-8d973d2bc283","fields":{"slug":"/spring-event/"},"frontmatter":{"title":"스프링 이벤트를 사용하여 도메인 의존성 분리하기"}}},{"node":{"id":"b1a9ce77-e471-5b77-a2c6-5d3532cfc926","fields":{"slug":"/base64url/"},"frontmatter":{"title":"Base64와 Base64Url의 차이 및 구글 로그인 Trouble Shooting"}}}]},"previous":{"fields":{"slug":"/react-query-reason/"},"frontmatter":{"title":"팀바팀 React query 도입이유"}},"next":{"fields":{"slug":"/base64url/"},"frontmatter":{"title":"Base64와 Base64Url의 차이 및 구글 로그인 Trouble Shooting"}}},"pageContext":{"id":"0bf82b69-7aee-5aa6-bb7e-8d973d2bc283","series":null,"previousPostId":"dde0edaf-b006-51f0-a50e-f47285556fc0","nextPostId":"b1a9ce77-e471-5b77-a2c6-5d3532cfc926"}},"staticQueryHashes":[],"slicesMap":{}}