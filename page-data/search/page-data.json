{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"해당 글은 우아한테크코스 5기 팀바팀 크루 성하가 작성했습니다!! ❌ 0. 문제 상황 서비스를 배포하고 나서 피드백을 받을 때, 일부 사용자의 구글 로그인이 정상적으로 작동하지 않는 문제가 발생했습니다.\n 서버의 로그를 확인해보니, 다음과 같은 에러가 발생하고 있었습니다.\n 구글 로그인에 관한 에러인데 왜 Base 64 에러가 뜨는지 상당히 궁금했었습니다…","fields":{"slug":"/base64url/"},"frontmatter":{"date":"August 20, 2023","title":"Base64와 Base64Url의 차이 및 구글 로그인 Trouble Shooting","tags":["Base64","Base64Url","구글 로그인"]},"rawMarkdownBody":"\n> 해당 글은 우아한테크코스 5기 팀바팀 크루 [성하](https://github.com/sh111-coder)가 작성했습니다!!\n\n<br>\n\n## ❌ 0. 문제 상황\n\n서비스를 배포하고 나서 피드백을 받을 때, 일부 사용자의 구글 로그인이 정상적으로 작동하지 않는 문제가 발생했습니다.\n![일부 사용자 구글 로그인 오류 페이지](./images/img.png)\n\n\n<br>\n\n서버의 로그를 확인해보니, 다음과 같은 에러가 발생하고 있었습니다.\n![서버 로그](./images/img_1.png)\n\n구글 로그인에 관한 에러인데 왜 Base 64 에러가 뜨는지 상당히 궁금했었습니다.\n\n그래서 구글링을 거쳐 **Base64와 Base64Url의 차이**라는 키워드를 알게 되었고,\n\n위의 키워드가 문제 원인 & 해결 방법을 제시해주고 있었습니다.\n\n---\n\n## 📘 1. Base64와 Base64Url의 차이\n\nBase64와 Base64Url의 차이를 알아보기 전에,\n\nBase64와 Base64Url이 무엇인지 간단하게 살펴봅시다.\n\n<br>\n\n### ✅ 1-1. Base64\n\n\n**Base64는 8비트 이진 데이터를 텍스트(ASCII 문자)로 인코딩하는 방식 중에 하나입니다.**\n\n파일 및 이미지나 중요한 정보를 Base64를 인코딩 하는 등 여러 컨텍스트에서 다양하게 사용이 가능합니다.\n\n\n\n예를 들어, 'Hello, World!'를 Base64로 인코딩하면 SGVsbG8sIFdvcmxkIQ==라는 문자열로 인코딩됩니다.\n![Base64 변환표 - 출처 : base64.guru](./images/img_2.png)\n\n이때, Base64를 사용하여 URL을 인코딩할 때 문제가 발생할 수 있습니다.\n\n\n\nBase64로 URL을 인코딩하게 되면, 62번 63번 문자인 '+'와 '/'의 문자가 인코딩될 수도 있습니다.\n\nURL에서 '+'는 공백을 의미하고 '/'는 Path 구분자의 역할을 수행합니다.\n\n따라서, 인코딩한 URL에 '+', '/'가 포함되면, URL에서 '+'와 '/'가 각각 문자열이 아니라 특별한 역할을 가지게 되어\n\n의도와는 다르게 동작할 수 있습니다.\n\n<br>\n\n따라서, 이를 보완하기 위해 **Base64Url**이 등장하게 되었습니다!\n\n\n<br>\n\n### ✅ 1-2. Base64Url\n\nBase64Url은 기본적으로 Base64와 인코딩 방식이 똑같습니다.\n\n대신, 위에서 의도와 다르게 동작할 수 있었던 62번, 63번 인덱스가 다른 값으로 변경된 방식입니다.\n![Base64Url 변환표 - 출처 : base64.guru](./images/img_3.png)\nBase64에서 의도와 다르게 동작할 수 있었던 62, 63번 인덱스인 '+'와 '/'가 '-'와 '_'로 변경된 걸 볼 수 있습니다.\n\n이를 통해 URL을 더욱 안전하게 인코딩 및 디코딩하여 사용할 수 있습니다.\n\n---\n\n## ❓ 2. 문제 원인\n\n그렇다면, 왜 구글 로그인에서 문제가 발생하고 있었던 걸까요?\n\n\n\n한번 천천히 따라가 봅시다.\n\n문제가 발생했던 코드는 다음과 같습니다.\n\n```java\nprivate String extractElementFromToken(final String googleIdToken, final String key) {\n    final String payLoad = googleIdToken.split(\"\\\\.\")[PAYLOAD_INDEX];\n    final String decodedPayLoad = new String(Base64.getDecoder().decode(payLoad));\n    final JacksonJsonParser jacksonJsonParser = new JacksonJsonParser();\n    return (String) jacksonJsonParser.parseMap(decodedPayLoad)\n            .get(key);\n}\n```\n\n구글이 제공하는 사용자 정보인 IdToken을 받아서, 해당 JWT IdToken에서\n\n이메일, 사용자 프로필 사진 등 여러 정보를 추출하는 메소드입니다.\n\n\n\n여기서 문제가 발생한 부분은 다음과 같습니다. \n```java\nfinal String decodedPayLoad = new String(Base64.getDecoder().decode(payLoad));\n```\n구글의 IdToken을 Base64 Decoder로 디코딩하여 정보를 가져오고 있는데요.\n\n왜 여기서 문제가 발생했을까요?\n\n<br>\n\nOpenID Connect 공식 문서의 IdToken 관련 정보를 살펴보면 다음과 같이 나와 있습니다.\n![OpenID Connect Core 1.0 incorporating errata set 1](./images/img_4.png)\n\n마지막 줄에 다음과 같이 나와 있습니다.\n\n> base64url로 인코딩합니다.\n\n구글 IdToken의 정보들은 Base64Url로 인코딩되어 있는데, 애플리케이션 코드에서는 Base64 Decoder를 사용하기 때문에\n\n오류가 발생한 것이었습니다.\n\n\n\n그렇다면, 왜 모든 사용자의 구글 로그인이 에러가 발생하는게 아니라 일부 사용자만 발생했을까요?\n\n해당 이유는 위의 Base64와 Base64Url의 차이에 있었습니다!\n\n위에서 살펴봤듯이, 둘의 차이는 62번, 63번 인덱스의 변환값이 다르다는 것이었는데요!\n\n\n\n구글이 IdToken을 Base64Url을 사용하여 인코딩할 때 62번 또는 63번 값인 '-', '_'가 포함되지 않는다면\n\nBase64로 디코딩을 해도 전부 디코딩이 가능하기 때문에 오류가 발생하지 않았던 것입니다.\n\n\n\n대신, '-', '_'가 포함된다면 Base64로는 해당 값을 디코딩할 수 없기 때문에 에러가 발생한 것입니다.\n\n---\n\n## ❓ 3. 문제 해결\n\n문제 해결은 정말 간단하게 할 수 있었습니다!\n\n애플리케이션의 코드에서 Base64 Decoder 대신 Base64 Url Decoder를 사용하여\n\nBase64Url로 디코딩을 진행하면 해결할 수 있었습니다!\n\n```java\n* 문제 발생 코드 (Base64 Decoding)\n  final String decodedPayLoad = new String(Base64.getDecoder().decode(payLoad));\n\n* 해결 (Base64Url Decoding)\n  final String decodedPayLoad = new String(Base64.getUrlDecoder().decode(payLoad));\n```\n\n\n---\n\n\n이번 문제는 운영 서버에서 처음으로 발생한 문제이고, 처음 해본 트러블 슈팅이었습니다.\n\n트러블 슈팅을 하면서 다음과 같은 로그를 보고 추적할 수 있었기 때문에 해결이 가능하다고 생각했습니다.\n\n![서버 로그](./images/img_1.png)\n\n그래서 Base64와 Base64Url의 차이도 깨닫게 되었지만\n\n더 중요한 것은 로깅 & 모니터링의 중요성을 알게 되었다는 점인 것 같습니다!\n"},{"excerpt":"해당 글은 우아한테크코스 5기 팀바팀 크루 성하가 작성했습니다!! 프로젝트를 진행하던 중 스프링 이벤트를 사용하게 되었습니다! 왜 스프링 이벤트를 사용했는지, 어떻게 사용하는지, 사용 시 고려할 점 등에 대해 자세히 알아보도록 하겠습니다! 0. 스프링 이벤트 도입 배경    프로젝트를 진행하면서 다음과 같은 요구사항이 존재했습니다. 팀 캘린더의 일정이 등…","fields":{"slug":"/spring-event/"},"frontmatter":{"date":"July 31, 2023","title":"스프링 이벤트를 사용하여 도메인 의존성 분리하기","tags":["Spring","Event","도메인 의존성 분리"]},"rawMarkdownBody":"\n> 해당 글은 우아한테크코스 5기 팀바팀 크루 [성하](https://github.com/sh111-coder)가 작성했습니다!!\n\n<br>\n\n프로젝트를 진행하던 중 스프링 이벤트를 사용하게 되었습니다!\n\n\n\n왜 스프링 이벤트를 사용했는지, 어떻게 사용하는지, 사용 시 고려할 점 등에 대해 자세히 알아보도록 하겠습니다!\n\n---\n\n## 0. 스프링 이벤트 도입 배경\n   프로젝트를 진행하면서 다음과 같은 요구사항이 존재했습니다.\n\n> 팀 캘린더의 일정이 등록, 수정, 삭제되면 팀 피드에 일정 알림이 생성된다.\n\n![일정 알림 디자인](images/img.png)\n\n위의 디자인처럼 팀 피드 공간에 팀 캘린더의 일정이 등록, 수정, 삭제되면 알림이 생성되도록 하는 요구사항이었습니다.\n\n(여기서 알림은 실시간 알림이 아니라 게시글처럼 생성되는 알림을 의미합니다.)\n\n\n<br>\n\n\n스프린트를 거쳐서 팀 캘린더의 일정 등록, 수정, 삭제 로직은 구현되어 있는 상태였으므로\n\n처음에는 단순하게 일정 알림 기능을 추가하면 된다고 생각해서 팀 캘린더 서비스에 다음과 같이 로직을 추가했습니다.\n\n\n```java\n@Service\n@Transactional\n@RequiredArgsConstructor\npublic class TeamCalendarScheduleService {\n\n    private final ScheduleRepository scheduleRepository;\n\t\n    // 일정 알림 Service 의존성 추가\n    private final NotificationService notificationService;\n\t\n\tpublic Long register(...) {\n        // 기존 일정 등록 로직\n        ...\n        \n        // 일정 알림 생성 로직 추가\n        notificationService.create(...);\n    }\n\n\tpublic void update(...) {\n        // 기존 일정 수정 로직\n        ...\n        \n        // 일정 알림 생성 로직 추가\n        notificationService.create(...);\n    }\n\n\n\tpublic void delete(...) {\n        // 기존 일정 삭제 로직\n        ...\n        \n        // 일정 알림 생성 로직 추가\n        notificationService.create(...);\n    }\n    \n    ...\n}\n```\n\n\n알림 생성 로직을 추가하고 생각을 해보았을 때 다음과 같은 문제가 생겼습니다.\n\n* **Schedule과 Notification 도메인 간의 강한 결합도**\n* **TeamCalendarScheduleService의 단일 책임 원칙(SRP) 위반**\n\n![Schdule - Notification 의존](images/img_1.png)\n\n<br>\n\n### 0-1. Schedule과 Notification 도메인 간의 강한 결합도\n먼저, Schedule 로직에 Notification 도메인 생성 로직이 존재하기 때문에 Schedule과 Notification이 강한 결합을 가지게 되었습니다.\n\n\n\n두 개의 도메인이 라이프 사이클이 비슷하거나 동일한 제약 사항을 공유한다면 결합을 가져도 괜찮다고 생각하지만,\n\n\n\nSchedule과 Notification 도메인은 라이프 사이클이 비슷하지 않고, 동일한 제약 사항도 공유하지 않습니다.\n\n\n\n이러한 상황에서 이후에 Notification의 생성 로직이 변경된다면 Schedule의 등록, 수정, 삭제 로직에 직접적인 영향을 미치게 될 것입니다.\n\n\n\n**따라서 서로 다른 두 도메인이 강한 결합도를 가져서 재사용성과 유지보수성이 떨어지게 됐습니다.**\n\n\n<br>\n\n### 0-2. TeamCalendarScheduleService의 단일 책임 원칙(SRP) 위반\n다음으로 ScheduleService의 단일 책임 원칙이 위반되었다고 생각했습니다.\n\n\n\n현재 구조에서는 ScheduleService, 즉 Schedule이 Notification을 생성하는 책임을 가지게 됩니다.\n\n\n\n일정의 입장에서 알림에 대해서는 알 필요가 없다고 생각했기 때문에\n\n\n\nSchdule -> Notification의 의존성을 없애는 것이 좋다고 생각하게 되었습니다.\n\n\n<br>\n\n\n\n\n위의 2가지 이유로 의존성을 없앨 수 있는 방법에 대해서 생각해보게 되었고,\n\n\n\n이전에 도메인 간의 의존성을 없앨 수 있는 방법인 스프링 이벤트에 대해 들어보았기 때문에 적용을 해보기로 했습니다!\n\n---\n\n## 1. 스프링 이벤트를 사용해서 의존성 분리하기\n   어떻게 스프링 이벤트를 사용하면 도메인 의존성을 분리할 수 있을까요?\n\n\n\n그림으로 요약해서 도식화해보면 다음과 같습니다.\n\n![스프링 이벤트 구조](images/img_2.png)\n\n\n\n\n\nScheduleService와 NotificationService 간의 의존성을 위와 같이 Event를 통해 해결할 수 있습니다.\n\n\n\nScheduleService에서 일정이 등록, 수정, 삭제되면 NotificationService의 알림 생성 로직을 실행하는 것이 아니라,\n\n\n\nScheduleEvent를 발행하기만 하고, ScheduleEvent가 발행되면 NotificationService에서 알림 생성 로직을 실행합니다.\n\n\n\n**이를 통해 Schedule이 Notification을 의존하는 문제를 해결할 수 있었고,**\n\n\n\n**ScheduleService에서는 Notification의 로직을 알 필요 없이 이벤트만 발행하면 되었습니다.**\n\n\n<br>\n\n\n### ✅ ApplicationEventPublisher\n```java\n@FunctionalInterface\npublic interface ApplicationEventPublisher {\n\n\tdefault void publishEvent(ApplicationEvent event) {\n\t\tpublishEvent((Object) event);\n\t}\n\n\tvoid publishEvent(Object event);\n```\n\n**이벤트를 발행할 곳에서 ApplicationEventPublisher의 publishEvent()를 통해서 이벤트를 발행할 수 있습니다.**\n\n\n\n스프링 4.2 이전에는 default 메소드밖에 없어서 Event 객체를 사용하려면 ApplicationEvent를 상속해야 했습니다.\n\n\n\n하지만 스프링 4.2 이후에는 일반 Object를 파라미터로 받는 publishEvent()가 추가되어\n\n일반 객체로도 이벤트를 생성할 수 있게 되었습니다.\n\n\n<br>\n\n\n### ✅  @EventListener\n**이벤트가 발행되면, @EventListener 어노테이션이 선언된 메소드에서 이벤트를 Listen해서 실행하게 됩니다.**\n\n\n**해당 메소드에서 발행 시에 파라미터로 넘겨준 Event 객체를 전달하여 로직에 사용할 수 있습니다.**\n\n```java\n@EventListener\npublic void executeEvent(final Event event) {\n...\n}\n```\n\n\n\n간단하게 스프링의 이벤트 발행 - 실행 Flow를 요약하면 다음과 같습니다.\n\n1. ApplicationEventPublisher가 publishEvent()로 이벤트 발행\n2. ApplicationContext가 발행된 이벤트를 @EventListener가 붙어있는 메소드에 전달\n3. @EventListener 메소드 로직 실행\n\n\n2번 과정을 살펴보면, ApplicationContext가 등장하게 됩니다.\n\nApplicationContext 클래스를 들어가보면, 다음과 같이 ApplicationEventPublisher를 상속받고 있습니다.\n```java\npublic interface ApplicationContext extends ApplicationEventPublisher, ... {\n\n}\n```\n\n따라서, 스프링이 실행되어 ApplicationContext가 로드됐을 때\n\n이벤트가 발행되면 ApplicationContext에서 @EventListener의 메소드를 실행하게 됩니다.\n\n<br>\n\n이렇게 스프링 이벤트의 이론적인 부분을 알아봤습니다!\n\n그렇다면 구체적으로 스프링 이벤트를 사용하여 리팩토링한 코드를 살펴봅시다!\n\n---\n\n## 2.  스프링 이벤트를 사용해서 기존 코드 리팩토링\n\n<br>\n\n### ✅ ScheduleService\n```java\n@Service\n@Transactional\n@RequiredArgsConstructor\npublic class TeamCalendarScheduleService {\n\n    private final ScheduleRepository scheduleRepository;\n\t\n    // ApplicationEventPublisher 추가\n    private final ApplicationEventPublisher eventPublisher;\n\t\n\tpublic Long register(...) {\n        // 기존 일정 등록 로직\n        ...\n        \n        // ScheduleCreateEvent 발행 로직 추가\n        eventPublisher.publishEvent(new ScheduleCreateEvent(...));\n    }\n\n\tpublic void update(...) {\n        // 기존 일정 수정 로직\n        ...\n        \n        // ScheduleUpdateEvent 발행 로직 추가\n        eventPublisher.publishEvent(new ScheduleCreateEvent(...));\n    }\n\n\n\tpublic void delete(...) {\n        // 기존 일정 삭제 로직\n        ...\n        \n        // ScheduleDeleteEvent 발행 로직 추가\n        eventPublisher.publishEvent(new ScheduleCreateEvent(...));\n    }\n    \n    ...\n}\n```\n\nScheduleService에서 NotificationService가 아닌\n\n이벤트 발행 객체 ApplicationEventPublisher를 사용해서 각 로직마다 이벤트를 발행해줬습니다.\n\n<br>\n\n\n\n### ✅ ScheduleEvent\n```java\n@Getter\npublic abstract class ScheduleEvent {\n\n    private final Long scheduleId;\n    private final Long teamPlaceId;\n    private final Title title;\n    private final Span span;\n\n    ...\n}\n```\n\n발행하는 ScheduleEvent는 NotificationService에서 알림 생성 시 필요한 정보만 담아서 구현했습니다.\n\n\n<br>\n\n\n### ✅ NotificationService\n```java\n@Service\n@Transactional\n@RequiredArgsConstructor\npublic class NotificationService {\n\n    private final NotificationRepository notificationRepository;\n\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    @TransactionalEventListener\n    public void createScheduleNotification(final ScheduleEvent scheduleEvent) {\n        ...\n    }\n}\n```\n\nNotificationService에서는 Event를 받아서 로직을 실행하기 위해\n\n@EventListener를 사용하여 이벤트가 발행되면 ApplicationContext에서 해당 메소드를 실행하도록 설정했습니다.\n\n(왜 @EventListener가 아닌 @TransactionalEventListener를 사용했는지와\n\n@Transactional의 propagation을 설정한 이유는 아래에서 설명하도록 하겠습니다!)\n\n---\n\n## 3.  스프링 이벤트 사용 시 고려할 점\n\n\n위처럼 생각보다는 간단하게 코드 리팩토링을 진행할 수 있었습니다.\n\n하지만, 간단했던 코드 구현과는 달리 스프링 이벤트를 사용할 때는 고려할 점이 많았습니다!\n\n이번 프로젝트의 스프링 이벤트를 사용할 때 고려했던 점들을 나열해보도록 하겠습니다.\n\n<br>\n\n### 3-1. Event 발행 후에 EventListener 로직을 바로 실행해도 되는가? (@TransactionalEventListener)\n\n\n![@EventListener 실행 시점](images/img_3.png)\n\n\n@EventListener를 사용한다면, 이벤트가 발행되는 시점에 바로 EventListener의 로직이 실행되게 됩니다.\n\n따로 EventListener의 로직 실행 시점을 특정해서 설정할 수 없습니다.\n\n\n\n이때 문제가 되는 것은, EventListener의 로직에서 예외가 발생했을 때의 상황입니다.\n\n예외가 발생하게 되면 트랜잭션이 롤백이 되는데 아래의 상황을 살펴봅시다.\n\n![EventListener 로직 롤백](images/img_4.png)\n\n순서대로 살펴봅시다.\n\n1. 일정 등록되어 이벤트 발행\n2. 이벤트가 발행되어 EventListener 로직 실행\n3. 일정 등록 메소드 안에서 다른 로직 수행\n4. 일정 등록 메소드가 종료되기 전 (Commit 되기 전) EventListener에서 예외가 발생하여 롤백\n\n이 경우는 EventListener 로직인 일정 알림 로직에 예외가 발생하여 롤백이 된 경우입니다.\n\n이때 일정 등록이 Commit이 되지 않았기 때문에 일정 알림 로직에 예외가 발생해서 롤백이 되는 건데\n\n일정 등록 로직까지 롤백이 되는 상황이 발생합니다.\n\n\n\n만약 해당 상황이 정상적인 경우는 그대로 @EventListener를 사용해도 되지만,\n\n저희 프로젝트에서는 일정 알림의 예외로 인해 일정의 등록, 수정, 삭제가 롤백되는 것은 비정상적인 상황으로 봤기 때문에\n\n다른 해결책을 찾게 되었습니다.\n\n<br>\n\n### ※ @TransactionalEventListener\n이 상황을 해결할 수 있는 것이 바로 @TransactionalEventListener입니다.\n\n위에서 언급했듯이 @EventListener를 사용할 때는 EventListener의 실행 시점을 지정할 수 없었습니다.\n\n@EventListener 대신 @TransactionalEventListener를 사용하면 트랜잭션 기준으로 실행 시점을 정할 수 있습니다.\n\n\n\n@TransactionalEventListener에서 phase 속성을 지정하면 실행 시점을 변경할 수 있습니다.\n\n```text\n1. BEFORE_COMMIT: 이벤트 발행 로직이 커밋되기 전에 실행\n2. AFTER_COMMIT : 이벤트 발행 로직이 커밋된 후에 실행 (기본값)\n3. AFTER_ROLLBACK : 이벤트 발행 로직이 롤백된 후에 실행\n4. AFTER_COMPLETION : 이벤트 발행 로직이 커밋 or 롤백된 후에 실행\n```\n   \n\n4가지 옵션으로 실행 시점을 변경할 수 있습니다.\n\n\n위의 상황을 방지하기 위해서는 일정 등록, 수정, 삭제 로직이 커밋된 후에 일정 알림 로직이 실행되어야 합니다.\n\n이렇게 설정을 하면 일정 알림 로직에서 예외가 발생하여 롤백이 되어도 일정 등록, 수정, 삭제는 이미 커밋이 되었으므로\n\n데이터가 롤백되지 않을 것입니다.\n\n\n따라서 프로젝트에서는 @TransactionalEventListener의 기본값인 AFTER_COMMIT를 사용했습니다!\n\n\n\n<br>\n\n### 3-2. @TransactionalEventListener를 사용한 상황에서, 데이터를 쓰는 로직이 있는가?\n@TransactionalEventListener를 사용할 때 AFTER_COMMIT 옵션을 사용하면 다음과 같은 상황이 됩니다.\n\n![@TransactionalEventListener AFTER_COMMIT 사용 상황](images/img_5.png)\n\n일정 등록 로직이 Commit된 이후에, EventListener의 로직이 실행됩니다.\n\n**이때 주의해야 하는 점이 트랜잭션에서 이미 Commit이 되었기 때문에 해당 트랜잭션에서는 조회밖에 수행할 수 없습니다.**\n\n\n\n그래서 EventListener 로직에 데이터를 insert, update, delete하는 로직이 존재한다면 해당 로직을 반영할 수 없습니다.\n\n\n\n이때, @Transactional의 propagation을 REQUIRES_NEW로 설정하게 되면 이를 해결할 수 있습니다.\n\n\n<br>\n\n### ※ @Transactional(propagation = Propagation.REQUIRES_NEW)\n@Transactional의 Propagation.REQUIRES_NEW는 해당 어노테이션이 붙은 메소드 호출 시\n\n매번 새로운 트랜잭션을 시작하게 됩니다.\n\n따라서, 트랜잭션 자체가 분리되기 때문에 이후 EventListener 로직의 Commit을 수행할 수 있습니다.\n\n![@Transactional(propagation = Propagation.REQUIRES_NEW)](images/img_6.png)\n\n\n\n저희 프로젝트에서는 EventListener 로직이 일정 알림을 생성해서 insert 하는 로직이 있었기 때문에\n\n@TransactionalEventListener와 함께 @Transactional(propagation = Propagation.REQUIRES_NEW)를 설정했습니다.\n\n\n<br>\n\n\n### 3-3. 비동기적으로 처리해야 하는 로직인가?\n스프링 이벤트 사용 시 비동기 처리도 가능합니다.\n\nEventListener 로직에 @Async로 비동기 어노테이션을 선언하고,\n\nApplication에 @EnableAsync를 선언하면 비동기 처리가 가능합니다.\n\n```java\n@Transactional(propagation = Propagation.REQUIRES_NEW)\n@TransactionalEventListener\n@Async\npublic void createScheduleNotification(final ScheduleEvent scheduleEvent) {\n    ...\n}\n```\n\n\n프로젝트에서는 EventListener 로직이 일정 알림 생성으로 단순하기 때문에 따로 비동기 처리를 해주지 않았습니다.\n\n나중에 하나의 EventListener 로직에서 여러 작업을 수행한다면 고려해볼 수 있을 것 같습니다!\n\n---\n\n지금까지 스프링 이벤트에 대해서 살펴봤습니다!\n\n**스프링 이벤트를 통해 도메인 의존성을 분리하고 서비스간의 결합도를 낮추는 효과를 얻을 수 있었습니다!**\n\n\n\n처음 사용해봤을 때 생각보다 이벤트를 발행하고 Listen해서 실행하는 구현이 간단해서 쉽다고 생각했습니다.\n\n그러나, 트랜잭션과 비동기와 관련해서 고려할 요소가 상당히 많았습니다.\n\n애플리케이션에 스프링 이벤트를 적용할 때 트랜잭션과 비동기 설정을 근거를 가지고 한다면 좋은 설계가 되지 않을까 싶습니다.\n\n"},{"excerpt":"해당 글은 우아한테크코스 5기 팀바팀 크루 루루가 작성했습니다! Husky 사용해서 commit 단위로 Lint 검사(Git Desktop 오류코드 127) Husky란? husky는 commit 또는 push 할 때 lint에 맞는지 확인하고, 테스트를 실행하는 것에 사용할 수 있다. 팀마다 컨벤션이 다양할 텐데 인간이 코드를 작성하는지라 어쩔 수 없이…","fields":{"slug":"/frontend-husky/"},"frontmatter":{"date":"July 24, 2023","title":"프론트엔드 Husky 사용해서 commit 단위로 Lint 검사","tags":["frontend","test"]},"rawMarkdownBody":"\n> 해당 글은 우아한테크코스 5기 팀바팀 크루 [루루](https://github.com/hafnium1923)가 작성했습니다!\n\n# Husky 사용해서 commit 단위로 Lint 검사(Git Desktop 오류코드 127)\n\n## Husky란?\n\nhusky는 commit 또는 push 할 때 lint에 맞는지 확인하고, 테스트를 실행하는 것에 사용할 수 있다.\n\n팀마다 컨벤션이 다양할 텐데 인간이 코드를 작성하는지라 어쩔 수 없이 컨벤션에 맞지않게 코드를 작성할 수도 있다.\n\n그럴때 husky를 사용하면 자동으로 검사해서 commit이든 push든 막아준다.\n\n팀바팀은 husky로 lint검사만 진행하는 것으로 결정했다.\n\n1. lint 검사는 commit 단위로 진행하는 것이 더 많은 수정을 막는다\n\n2. test를 commit단위로 진행하는 것은 필요없는 commit이 더 많기도 하고 전체 파일에서의 통과 여부가 더 중요하기 때문에 PR 단위로 진행한다.\n\n라는 이유였다!\n\n### Husky 설치하기\n\n```\nnpm i -d husky\n```\n\n명령어 넣기\n\n```\n//package.json\n\"scripts\": {\n  ...\n    \"prepare\": \"cd .. && husky install frontend/.husky && cd frontend\"\n  },\n```\n\n우리는 하나의 레포에서 각각 백엔드 프론트엔드 파일을 만들어서 사용하고 있기 때문에 frontend 폴더로 이동하는 것도 추가했다\n\n### lint-staged 설치하기\n\nlint-staged란 문법 오류나 스타일 오류를 분석하고 표시, 수정하는 도구이다.\n\n```\nnpm i -d lint-staged\n```\n\n설치했으면 설정도 해주자\n\n```\n//package.json\n\"lint-staged\": {\n    \"*.{ts,tsx}\": [\n      \"eslint --cache\"\n    ],\n    \"*.{ts,tsx,md,json}\": [\n      \"prettier --write\"\n    ]\n  }\n```\n\n각각 확장자로 끝나는 파일들을 어떤 거로 검사할건지 정해주는 거다.\n\n+) --cache는 캐싱해주는 옵션으로 한 파일만 고쳤는데 나머지 코드들이 의미없이 포맷팅되는 상황을 막아준다. 즉, 전과 후를 비교해 비교를 최소화해준다.\n\n### pre-commit 파일\n\n```\n#!/bin/sh\n. \"$(dirname \"$0\")/_/husky.sh\"\n\ncd frontend\nnpx lint-staged\n```\n\n마찬가지로 프론트엔드 폴더로 이동 후 커맨드를 실행시키게 하자\n\n추가적으로 깃 데스크탑을 사용하면 조금 바뀐다.\n\n## Git Desktop에서 husky 오류\n\n내가 깃 데탑을 써서 그런가, 아님 윈도우라 그런가, 아님 그 둘다라서 husky 억까를 당했다. storybook과 npm배포에 이어 또 억까.. 그냥 한달에 한번 환경억까당한다고 생각해야 마음 편할듯.\n\n커밋하려고 하니까 이런 에러가 떴다. (아래 가린건 신경안써도 된다) 근데 VScode에서는 commit이 아주아주 잘된다.\n\n![https://blog.kakaocdn.net/dn/beyYO1/btsn6HDjKtq/u1sDGEqQV5vFj1lgkfzlkk/img.png](https://blog.kakaocdn.net/dn/beyYO1/btsn6HDjKtq/u1sDGEqQV5vFj1lgkfzlkk/img.png)\n\n이거 두개 이슈 보면서 환경변수 추가했는데 안됐다.(추가하라는거 다 한듯?)\n\n[Code 127 error · Issue #1038 · typicode/husky\nTroubleshoot [ x ] Before creating an issue, please check: https://typicode.github.io/husky/#/?id=troubleshoot Context We had husky 7.0.1 working fine in our repo. But a few days ago it stopped wor...\ngithub.com](https://github.com/typicode/husky/issues/1038)\n\n[Win 10 Github Desktop pre-commit hook · Issue #1072 · typicode/husky\nHello, I have a problem with my pre-commit hook or husky in general when using Github Desktop. On the first look, it seems to be #1038, but the problem is. It works perfectly fine in VS code. My en...\ngithub.com](https://github.com/typicode/husky/issues/1072)\n\n### 해결방법\n\n진짜 간단하다.\n\n.husky\\pre-commit 에서 이렇게 하면 된다.\n\n```\n#!/bin/sh\n. \"$(dirname \"$0\")/_/husky.sh\"\n\ncd frontend\nnpx.cmd lint-staged\n```\n\nnpx  -> npx.cmd\n\n단, 이렇게 하면 맥에서는 아예 작동을 하지 않는다ㅋㅋ.. 그래서 나는 일단 브랜치에서 작업할 때마다 .cmd를 붙여주고있다.\n\n다른 방법 알면 알려주세요...\n\n끋!"},{"excerpt":"해당 글은 우아한테크코스 5기 팀바팀 크루 루루가 작성했습니다! React query 도입이유 react-query 사용을 고려하게된 이유 팀바팀의 핵심 기능인 캘린더는 등록,수정,삭제가 일어날 때 전체 일정과 개별 일정의 최신화가 보장되어야 함. 이후에 추가될 기능들 또한 최대한의 최신화가 보장되어야 함. 즉 서버,클라이언트 데이터를 분리하여 관리 할 …","fields":{"slug":"/react-query-reason/"},"frontmatter":{"date":"July 24, 2023","title":"팀바팀 React query 도입이유","tags":["frontend","react-query"]},"rawMarkdownBody":"\n> 해당 글은 우아한테크코스 5기 팀바팀 크루 [루루](https://github.com/hafnium1923)가 작성했습니다!\n\n# React query 도입이유\n\n### react-query 사용을 고려하게된 이유\n\n팀바팀의 핵심 기능인 캘린더는 등록,수정,삭제가 일어날 때 전체 일정과 개별 일정의 최신화가 보장되어야 함. 이후에 추가될 기능들 또한 최대한의 최신화가 보장되어야 함. 즉 서버,클라이언트 데이터를 분리하여 관리 할 수 있기 때문에 도입을 고려하게 됨. \n\n### react-query을 도입했을 때 장점\n\n- 캐싱\n    - 동일한 데이터를 여러번 요청하면 캐싱된 데이터를 가져오기 때문에 불필요한 통신을 줄일 수 있음.\n        - 캘린더에서 달을 이동할 때 항상 전체 일정을 get한다. 전체 일정에서 개별 일정을 조회할 때마다 해당 일정을 get한다.\n- get한 데이터에 대해 update를 진행하게 되면 자동으로 get을 수행한다.\n    - 개별 일정에 대해 수정, 삭제를 하게되면 전체 일정 또한 invalidateQueries를 통해 쿼리가 오래되었다는 것을 알려주어 데이터를 가져오게 한다.\n- 비동기 과정을 선언적으로 관리할 수 있다.\n- 서비스의 특성상 각각 기능별 페이지와 모아보기 페이지에서 데이터를 사용하는데 이 데이터를 저장하는 불필요한 전역 상태를 만들지 않아도 된다.\n- react-query를 통해 성공, 에러, 로딩, 패칭 등 다양한 상태를 알 수 있기 때문에 간단하게 상황에 따라 맞는 UX/UI를 사용자에게 제공할 수 있다.\n\n- UX\n    - 협업을 위한 서비스 특성 상 서버 상태 동기화의 필요성이 높아짐\n        - react-query의 background refetch를 활용하여 사용자에게 서버의 최신 상태를 보여줄 수 있음\n        - refetchOnWindowFocus 등을 활용하여 탭 전환 / 윈도우 포커스 시 그동안 다른 사용자가 업데이트한 데이터를 보여줄 수 있음\n    - Suspense, ErrorBoundary를 할용하여 선언적으로 비동기 로직의 로딩 / 에러 상태를 처리할 수 있음\n    - 캐싱을 활용하여 불필요한 비동기 요청 횟수를 줄일 수 있음"},{"excerpt":"해당 글은 우아한테크코스 5기 팀바팀 크루 루루가 작성했습니다! 프론트엔드 Github Action 테스트 자동화 팀바팀은 github action을 이용해 프론트엔드 PR시 테스트를 잘 통과하는지 자동으로 테스트하고 있다. 또한, 추후에 Build시 빌드가 잘 되는지 자동으로 테스트할 예정이다. 테스트 자동화를 하면 여러명이 하나의 프로젝트를 같이 진행…","fields":{"slug":"/frontend-ci/"},"frontmatter":{"date":"July 24, 2023","title":"프론트엔드 Github Action 테스트 자동화","tags":["frontend","test"]},"rawMarkdownBody":"\n> 해당 글은 우아한테크코스 5기 팀바팀 크루 [루루](https://github.com/hafnium1923)가 작성했습니다!\n\n# 프론트엔드 Github Action 테스트 자동화\n\n팀바팀은 github action을 이용해 프론트엔드 PR시 테스트를 잘 통과하는지 자동으로 테스트하고 있다. 또한, 추후에 Build시 빌드가 잘 되는지 자동으로 테스트할 예정이다. 테스트 자동화를 하면 여러명이 하나의 프로젝트를 같이 진행하는 만큼 나의 코드가 기존의 테스트에 영향을 주는지 사람이 직접 확인하지 않아도 쉽게 확인할 수 있다. 테스트가 통과하지 못한다면 merge를 하지 못하게 막아 merge시 안전성을 높일 수 있다.\n\n# Github Action을 이용한 테스트 자동화\n\ngithub workflows의 하위에 다음과 같은 파일을 넣는다. 확장자는 `.yml`이다.\n\n자세한 내용은 아래 주석으로 작성했다.\n\n```jsx\nname: frontend-ci //액션의 이름\n\non:\n  pull_request: //PR 요청일 때\n    branches:\n      - develop //해당 브랜치에서 PR이벤트가 일어났을 때 실행 \n    paths:\n      - frontend/** //frontend하위 폴더에서 작업이 일어날때만 실행\n\njobs:\n  unit-test:\n    runs-on: ubuntu-latest //어떤 머신으로 실행할건지\n    permissions:\n      contents: write //GITHUB_TOKEN에 부여된 기본 사용 권한\n    concurrency: //동시성 제어\n      group: ${{ github.workflow }}-${{ github.ref }} //동시성을 제어할 그룹 설정\n      cancel-in-progress: true //동시에 돌아가게 된다면 가장 최신의 워크플로우 실행\n    env:\n      working-directory: ./frontend //어디에서 커맨드를 실행 할 건지 \n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n\n      - name: Setup node with cache //종속성 파일 캐싱하기.(각 PR 별로 생성된다) \n        uses: actions/setup-node@v3\n        with: //캐싱하는 방법\n          node-version: 18\n          cache: 'npm'\n          cache-dependency-path: '**/package-lock.json'\n\n      - name: Install dependencies //종속성 설치하기\n        run: npm ci\n        working-directory: ${{ env.working-directory }}\n\n      - name: Run unit test //테스트 실행하기\n        run: npm run test:ci \n        working-directory: ${{ env.working-directory }}\n```\n\n캐싱 관련해서는 아래 자료 참고하면 더 자세히 알 수 있다.\n\n[Caching dependencies to speed up workflows - GitHub Docs](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows)\n\n[GitHub Actions: Setup-node supports dependency caching for projects with monorepo and pnpm package manager](https://github.blog/changelog/2021-09-07-github-actions-setup-node-supports-dependency-caching-for-projects-with-monorepo-and-pnpm-package-manager/)\n\n# PR Merge 막기\n\n열심히 테스트 자동화를 했는데 테스트 실패한 PR이 merge되면 무슨 소용이 있을까. 다행히 github에서는 테스트가 통과하지 못하면 merge 하지 못하게 해주는 설정이 있다.\n\n## 레포 설정 → 브랜치\n\n![Untitled](./images/Untitled.png)\n\n팀바팀은 개발용 브랜치 develop과 배포 브랜치 main를 사용하기 때문에 이렇게 두개가 올라가 있다. 처음 룰을 등록한다면 오른쪽 위에 있는 Add rule을 눌러 추가한다.\n\n아래 내려서 이 항목을 체크해주면 끝!\n\n![Untitled](./images/Untitled%201.png)"},{"excerpt":"해당 글은 우아한테크코스 5기 팀바팀 크루 루루가 작성했습니다! 팀바팀의 컴포넌트 스타일링 방법을 선택하기전 각각의 장점과 단점을 찾아보았다. 이것말고도 더 많은 장단점이 있지만 선택에 중요한 판단이 되고 공감가능한 장단점을 위주로 찾아보았다. CSS 단점 모든 클래스의 이름이 전역적으로 존재하기 때문에 별도의 class 명명 규칙이 필요하다 하나의 요소…","fields":{"slug":"/component-styling/"},"frontmatter":{"date":"July 17, 2023","title":"팀바팀 컴포넌트 스타일링 방법 선택","tags":["frontend","기획"]},"rawMarkdownBody":"\n> 해당 글은 우아한테크코스 5기 팀바팀 크루 [루루](https://github.com/hafnium1923)가 작성했습니다!\n\n팀바팀의 컴포넌트 스타일링 방법을 선택하기전 각각의 장점과 단점을 찾아보았다. 이것말고도 더 많은 장단점이 있지만 선택에 중요한 판단이 되고 공감가능한 장단점을 위주로 찾아보았다.\n\n## CSS\n\n### 단점\n\n- 모든 클래스의 이름이 전역적으로 존재하기 때문에 별도의 class 명명 규칙이 필요하다\n- 하나의 요소에 여러 css 가 적용될 수 있어, 개발자가 모든 스타일을 기억해야한다.\n- js의 상태 값을 공유하기 어렵다.\n- css 로드 순서에 따라 우선순위가 달라지기 때문에 css 로드 순서를 기억해야한다.\n- 하위 컴포넌트가 부모 컴포넌트의 스타일링에 영향을 받는다.\n\n⇒ 유지보수의 측면에서도, 협업의 측면에서도 단점이 명확함\n\n## CSS-in-JS\n\n### 장점\n\n- class 명이 빌드 타임에 유니크하게 변경되어 명명규칙이 필요없음\n- CSS가 컴포넌트 단위로 추상화되기 때문에 CSS간 의존성 고려 필요없음\n- JS의 상태 값을 공유할 수 있음 (동적스타일링이 가능)\n- CSS가 지역(컴포넌트) 스코프에 적용되므로 우선순위에 따른 문제가 없음\n- CSS가 컴포넌트에 격리되어 있기 때문에 상속 문제가 없음\n\n### 단점\n\n- 번들 크기를 늘린다.\n- 렌더링 속도가 느려진다\n- CSS 파일이 없으므로 별도의 CSS를 캐시할 수 없다.\n- 간단한 스타일에도 상용구 코드가 많다.\n\n⇒ 프로젝트 성능에는 영향을 미치지만 TS와 연결을 자동으로 해준다는 점, 협업을 할 때 따로 명명 규칙을 정하지 않아도 되는점, 스타일이 컴포넌트에 종속되어있다는 점, 동적 스타일링이 가능한 점이 장점이다.\n\n## CSS module\n\n### 장점\n\n- CSS를 JS에 적용하는 것이 쉽다.\n- CSS가 지역(컴포넌트) 스코프에 적용된다.\n\n### 단점\n\n- 전역 스타일 설정이 어렵다.\n- TS로 작업하려면 자동/수동으로 인터페이스를 생성해야함\n\n⇒ CSS-in-JS와 장점은 비슷하지만 전역적으로 스타일을 할 때 어렵다는 점, TS로 작업하려면 추가로 손봐야한다는점이 단점이다.\n\n## Styled Components VS emotion\n\n- 전반적인 스타일 기능은 동일\n- 성능면에서 emotion이 조금 더 가볍고 빠르다.\n    - 다만 그렇게 유의미한 차이라고 보기엔 어렵다고 한다.\n- emotion\n    - css props 기능\n        - 인라인 스타일로 작성하면 클래스로 변환된다.\n    - 서버 사이드 렌더링 설정시 별도의 추가 설정을 안해도 된다.\n    - 파일마다 pragma line을 추가해야한다.\n\n## 결론\n\n우리 팀의 선택은 CSS-in-JS이다. 프로젝트를 하면서 3명이 일관성있게 코드를 짜기위해 이미 여러 컨벤션이 있는데 class 이름까지 신경쓰는 것은 낭비라 생각했다. 또한 우리 프로젝트는 TypeScript를 적용하기 때문에 따로 설정을 하지 않아도 되는 점이 매력적이었다. 동적 스타일링도 선택의 이유였다. 우리는 사용자가 여러 팀에 속해있을 때 팀별로 색을 다 다르게 보여주기 위해서 동적으로 스타일링이 되어야만 했다.\n\n물론 프로젝트 성능저하라는 단점이 있지만 현재 단계에서는 큰 프로젝트가 아니기 때문에 그정도는 감수할 수 있다고 생각했다.\n\n라이브러리중에는 styled components를 선택했다.\n\n성능면에서는 emotion이 조금 더 가볍고 빠르다. 하지만 큰 차이가 없는데 파일마다 pragma line을 추가해야하는 것은 불필요한 시간낭비라고 생각했다.(까먹을 수도 있으니 말이다). 또한 이모션의 가장 큰 장점이라고 생각하는 서버 사이드 렌더링 관련해서 우리는 필요없을 것이라고 판단했기 때문이다."},{"excerpt":"해당 글은 우아한테크코스 5기 팀바팀 크루 성하가 작성했습니다!! 🌈 이벤트 스토밍(Event Storming) 도입기 우아한테크코스 5기 팀바팀 Project에서 Event Storming을 처음 사용해보면서 적용했던 배경과 적용 과정, 적용 후에 느낀점 등을 간단하게 기록하고자 합니다! 🎯 이벤트 스토밍 도입 배경 프로젝트 팀원이 배정되기 전에, DD…","fields":{"slug":"/event-storming/"},"frontmatter":{"date":"July 01, 2023","title":"팀바팀 이벤트 스토밍(Event Storming) 도입기","tags":["기획","설계"]},"rawMarkdownBody":"\n> 해당 글은 우아한테크코스 5기 팀바팀 크루 [성하](https://github.com/sh111-coder)가 작성했습니다!!\n\n\n## 🌈 이벤트 스토밍(Event Storming) 도입기\n\n우아한테크코스 5기 팀바팀 Project에서 Event Storming을 처음 사용해보면서\n\n적용했던 배경과 적용 과정, 적용 후에 느낀점 등을 간단하게 기록하고자 합니다!\n\n\n\n\n## 🎯 이벤트 스토밍 도입 배경\n\n프로젝트 팀원이 배정되기 전에,\n\nDDD에 대해 공부해보면서 자연스럽게 DDD 도입 시 쉽게 DDD를 도입할 수 있는 방법을 접하게 되었습니다.\n\n그게 바로 이벤트 스토밍(Event Storming)이었습니다.\n\n<br>\n\n처음에는 'DDD를 쉽게 할 수 있다고?' 라는 생각으로 이벤트 스토밍에 흥미를 가지고 공부를 해봤습니다.\n\n공부를 한 뒤에 느낀 생각은 다음과 같았습니다.\n\n> DDD 뿐만 아니라 기획, 설계 시에 적용하면 좋겠는데?\n\n뒤에서 소개하겠지만, 이벤트 스토밍을 하고 나면 팀원 모두가 공통된 이해를 가지는 효과때문에\n\n위와 같은 생각을 하게 되었습니다.\n\n<br>\n\n그래서 결국 팀 첫 회의 날에 이벤트 스토밍을 해보자고 주장했고, 도입하게 되었습니다!\n\n\n## 🎯 이벤트 스토밍이란?\n\n간단하게 이벤트 스토밍에 대해서 설명하고 넘어가겠습니다!\n\n이벤트 스토밍이란, **복잡한 비즈니스 도메인을 빠르게 탐색하고 학습할 수 있는 방법입니다.**\n\n**코드로 소통하지 않고 모든 사람이 공통된 도메인 이해를 가지도록 하는 방법입니다.**\n\n<br>\n\n포스트잇 색상으로 개념들을 구분하고, 해당 개념에 따라 포스트잇을 붙여가면서 도메인 이해를 해나가는 방법입니다.\n\n![포스트잇 색상에 따른 개념](images/event-stroming-postit.png)\n\n\n일반적으로 이벤트 도메인에 사용되는 포스트잇의 색상에 따른 개념은 위의 사진과 같습니다.\n\n간단하게 색상별 개념을 알아보도록 하겠습니다.\n\n```text\n1. 주황색 : '도메인 이벤트' - 서비스에서 발생할 수 있는 도메인별 이벤트\n2. 노란색 : '액터' - 단순한 사용자, 고객보다 구체적인 페르소나\n3. 파란색 : '액션' - 시스템에서 일어나는 일, 도메인 이벤트가 발생하는 원인\n4. 초록색 : '정보' - 액터가 액션을 실행하는 데에 필요한 정보\n5. 보라색 : '정책' - 도메인 이벤트와 액션 사이에 위치해서 '주로 ~할 때마다'로 시작하는 정책\n```\n구체적인 색상별 예시는 아래에서 더 설명하겠습니다.\n\n\n\n말로만 들으면 어떤 방법인지 감이 안 올 수 있기 때문에,\n\n어떻게 공통된 도메인 이해를 가질 수 있는지 진행 방식 및 과정을 보면서 이해해봅시다.\n\n\n## 🎯 이벤트 스토밍 진행 방식\n\n이벤트 스토밍을 하기 위한 준비물은 큰 종이나 큰 화이트보드, 포스트잇과 펜 정도면 충분합니다!\n\n\n\n이벤트 스토밍은 단계별로 진행됩니다!\n\n여러 참고 자료를 공부해본 결과, 자료마다 포스트잇 색상이 의미하는 개념은 대부분 비슷했지만\n\n어떤 단계로 진행하는 지는 부분부분 달랐습니다.\n\n\n\n저희 팀은 아래의 영상에 나오는 단계를 참고하여 진행했습니다!\n참고는 했지만,\n\n처음 진행해본 것이기도 하고 부분적으로 단계별로 진행하지 않았던 부분도 있어서 완전히 똑같게 진행하지는 않았습니다!\n\n[KCD 2020 TRACK 2 : 도메인 지식 탐구를 위한 이벤트 스토밍](https://www.youtube.com/watch?v=hUcpv5fdCIk&ab_channel=OpenUP-%EC%98%A4%ED%94%88%EC%97%85) \n\n그럼, 저희 팀에서 이벤트 스토밍을 진행했던 단계를 경험 기반으로 소개해보겠습니다!\n\n(단계 이름은 제 맘대로 정해보겠습니다!)\n\n### ✅ 1단계 : 도메인 이벤트 흩뿌리기\n\n1단계에서는 팀의 서비스에서 발생할 수 있는 이벤트들을 **주황색 포스트잇**에 생각나는대로 적어서 붙이는 단계입니다.\n\n저희 서비스는 '여러 팀플 참여 시 쉽게 협업을 할 수 있도록 도와주는 서비스'이므로,\n\n다음과 같은 이벤트가 공통적으로 발생합니다.\n\n(아래 이벤트만 있는 것이 아니라 무수히 많은 이벤트가 발생하겠죠?!)\n\n```text\n1. 로그인이 성공하였다.\n2. 팀 플레이스가 생성되었다.\n3. 팀별 캘린더 일정 등록이 성공하였다.\n```\n\n이처럼, 각자의 생각으로 서비스에 맞는 도메인의 이벤트들을 적어서 붙이면 됩니다.\n\n\n이때, 하나의 큰 종이에 포스트잇을 붙여나가면서 다른 팀원들의 이벤트를 볼 수는 있지만\n\n'그 이벤트가 필요할까?'와 같은 토론은 지양하고, 팀원들 각각 자신의 생각대로 이벤트를 적어서 붙입니다.\n\n저희 팀 같은 경우는 1단계 마무리 시 다음과 같이 큰 종이에 빽빽하게 채워질 만큼의 도메인 이벤트가 도출되었습니다.\n\n![이벤트 스토밍 1단계](images/1st.png)\n\n\n### ✅ 2단계 : 도메인 이벤트 타임 라인 순으로 정리 & 토론 시작\n\n1단계를 마무리했다면, 수많은 도메인 이벤트가 큰 종이에 붙어있을 것입니다.\n\n2단계가 이벤트 스토밍의 Main 단계라고 생각이 듭니다.\n\n\n\n2단계에서는 1단계에서 팀원들이 각각의 생각대로 도출한 도메인 이벤트를 타임 라인 순으로 정리합니다.\n\n타임 라인 순으로 정리하면서 중복이라고 생각되는 이벤트들은 제거합니다.\n\n정리를 해나가면서, 팀원들과 토론이 필요한 부분은 토론하면서 필요한 이벤트들만 남겨놓습니다.\n\n\n\n도메인 이벤트를 중복이라고 여겨서 제거할 때 중요한 점은,\n\n**동일한 용어인 이유로 중복일 때 다른 개념일 수 있으므로 100% 중복인 도메인 이벤트만 제거해야합니다.**\n\n\n\n예를 들어, 팀원 A와 B가 똑같이 '로그인이 성공했습니다.' 이벤트를 작성했을 때,\n\nA는 자체 로그인으로 생각했고, B는 소셜 로그인으로 생각했다면 이 두 개의 이벤트는 다른 이벤트입니다.\n\n따라서 제거하는 것이 아니라 구체화해야 할 것입니다.\n\n\n\n이렇듯, 도출한 이벤트를 제거할 때는 100% 중복이 맞는지 확인 후에 제거해야합니다.\n\n\n\n이 단계에서 한 가지 더 중요한 포인트는 바로 **토론을 시작한다는 점**입니다!\n\n도메인 이벤트에 대한 토론을 시작하면서 많은 갈등 및 충돌이 발생할 것입니다!\n\n\n\n**이때, 자주색 포스트잇을 이용하여 어떤 부분에서 토론을 했는지에 대해 토론을 한 도메인 이벤트 옆에 붙여주는 것이 중요합니다.**\n\n**이후에 자주색 포스트잇에 적혀있는 토론 부분들을 해결해 나가면서 공통된 이해를 도출할 수 있습니다!**\n\n\n다음은 저희 팀이 진행한 2단계 결과입니다.\n\n저희 팀의 경우에는 분홍색 포스트잇에 용어 후보들이나, 해당 기능을 넣을지 말지 등의 고민들을 적어 놓고\n\n이후에 해당 포스트잇을 보고 해결해나갔습니다.\n\n(자주색 포스트잇이 없어서 불가피하게 분홍색 포스트잇으로 토론이 발생한 부분을 나타냈습니다.)\n\n![이벤트 스토밍 2단계 - 1](images/2nd-1.png)\n![이벤트 스토밍 2단계 - 2](images/2nd-2.png)\n\n\n### ✅ 3단계 : 액터 & 액션 & 리드 모델 & 정책 설정 + 토론 결론 내기\n\n2단계를 거쳐서 타임 라인이 결정된 이후에 저희 팀은 다시 한번 도메인 Flow를 하나씩 살펴보며\n\n액터 & 액션 & 리드 모델 & 정책을 생각나는 대로 개념에 맞는 포스트잇 색상으로 붙여나갔습니다.\n\n\n\n보통의 2단계에서는 노란색 포스트잇으로 **구체적인 사용자 페르소나를 뜻하는 액터**를 설정하지만,\n\n저희 팀은 서비스 Flow에서 액터가 거의 '멤버' 1개라고 생각했기 때문에, 따로 액터 포스트잇은 붙이지 않았습니다.\n\n\n\n다음으로, **도메인 이벤트가 발생하는 원인인 액션**을 파란색 포스트잇으로 붙여나갔습니다.\n\n붙어져 있는 모든 도메인 이벤트들의 액션을 생각해보며 자연스럽게\n\n**액터가 액션을 내리는데 필요한 정보**를 초록색 포스트잇으로,\n\n**도메인 이벤트와 액션 사이에 위치한 정책**을 진한 노랑색 포스트잇으로 붙여나갔습니다.\n\n(원래는 정책은 보라색 포스트잇이지만 없어서 진한 노랑색 포스트잇으로 대체했습니다.)\n\n\n\n정보, 정책 개념에 대해 사용했던 예시를 들어보자면 다음과 같이 들어볼 수 있습니다.\n```text\n1. 정보 : '팀별 캘린더 일정 등록' 액션을 하기 위해 필요한 정보\n    - 일정 이름\n    - 시작 기간\n    - 종료 기간\n\n2. 정책 : 도메인 이벤트와 액션 사이에 위치해서 도메인 이벤트가 발생할 때마다 액션을 수행하게 하는 트리거\n    - '팀 플레이스에서 나갔다' 도메인 이벤트가 발생할 때, '팀 플레이스가 삭제되었다.'가 수행되는 조건\n    - '팀 플레이스 멤버가 0명이면' : 정책\n```\n![정보 (초록색) 예시](images/info.png)\n![정책 (보라색) 예시](images/policy.png)\n\n\n이 단계에서는 액션, 정보, 정책 붙이기 이외에 더 중요한 작업이 있었습니다.\n\n중요한 작업은 바로, 2단계에서 붙여놨던 토론 부분들을 다시 살펴보면서 해결해나가는 과정입니다.\n\n이를 통해 용어나 해당 기능의 개발 여부 등 여러 갈림길들을 하나의 길로 만들어서 싱크를 맞췄습니다.\n\n\n\n저희 팀은 이러한 3단계 과정 끝에 공통된 도메인 이해를 가지고 개발 단계에 접어들 수 있었습니다!\n\n다음은 완성한 저희 팀의 이벤트 스토밍 결과물입니다!\n\n(최소 기능들만 우선 구현하자는 공동의 목표로 가지고 임했기 때문에 이벤트들을 많이 제거하게 되었습니다.)\n\n![이벤트 스토밍 3단계 - 1](images/result-1.png)\n![이벤트 스토밍 3단계 - 2](images/result-2.png)\n\n## 🎯 피그잼에 이벤트 스토밍 결과 옮기기\n\n저희 팀은 **오프라인**으로 이벤트 스토밍을 진행했습니다.\n\n이때 1단계에서 진행한 도메인 이벤트 포스트잇은 공통된 '유비쿼터스 언어'를 정의하기 전에 작성된 것이기 때문에\n\n용어들이 공통된 용어로 작성되지 못했습니다.\n\n\n\n예를 들면, 이벤트 스토밍이 끝난 후에는 '파일 업로드 하는 공간'을 '팀 드라이브'로 정의를 마쳤는데,\n\n1단계에서 작성한 주황색 포스트잇에서는 '공유 드라이브'라는 용어로 표현되어 있는 경우가 많았습니다.\n\n이러한 이유 때문에 온라인으로 옮기면서 용어를 공통된 용어로 수정해야겠다고 생각했고,\n\n\n\n또한 이미 작성했던 포스트잇 부분에 변경 사항이 생기거나 추가할 필요가 생길 때\n\n불편한 점이 많다고 느끼게 되어서 디자인 툴인 피그잼에 이벤트 스토밍 결과를 옮기게 되었습니다.\n\n\n\n그렇다고 해서, **오프라인에서 직접 포스트잇을 붙이며 진행한 이벤트 스토밍이 의미가 없다고 생각하지는 않습니다.**\n\n오히려 7명의 팀원이 각자의 화면에서 이벤트 스토밍을 진행했다면\n\n집중이 분산되어서 결과물의 퀄리티가 더 낮아졌을 것이라고 저는 느꼈습니다!\n\n\n\n또한, 오프라인으로 진행한 이벤트 스토밍 결과를 온라인으로 옮길 때\n\n한번 더 설계한 서비스의 Flow를 되새기면서 놓쳤던 부분을 발견해서 더 나은 설계가 되기도 했습니다.\n\n\n\n다음은, 피그잼으로 옮긴 저희의 이벤트 스토밍 결과물입니다.\n\n![이벤트 스토밍 결과물 in FigJam](images/real-result.png)\n\n## 🎯 이벤트 스토밍 진행 후 느낀점\n\n저희 팀 프로젝트 진행 전에 이벤트 스토밍을 스스로 도입해야겠다고 생각했던 이유는\n\n앞에서도 말했듯이 DDD를 하기 위함이 아닌, **팀원 모두가 공통된 이해를 가지는 효과**를 얻기 위해서였습니다.\n\n\n\n**저희 팀에 맞게 줄인 이벤트 스토밍의 3단계를 진행하고 나서 경험한 바로는**\n\n**팀원 모두가 공통된 이해를 가지는 효과를 경험해봤습니다! 😃 👍**\n\n**그래서 너무 만족하게 되었습니다!**\n\n\n\n이벤트 스토밍 진행 중이나, 끝나고 난 후에 팀원들이 모두\n\n우리가 이벤트 스토밍을 진행하면서 정한 공통의 언어인 **유비쿼터스 언어**를 사용하고 있었고,\n\n기능 구현 우선 순위나 해당 기능의 정책 등 여러 결정 사항이 도출되었습니다.\n\n\n\n아래는 저희 팀이 이벤트 스토밍에서 정립한 저희 팀의 **용어 사전**입니다.\n\n\n### 📕 용어 사전\n\n![용어 사전](images/dictionary.png)\n\n\n이렇듯, 처음 진행해서 미숙했음에도 불구하고 **팀원 모두가 '공통된 이해'를 가지고,**\n\n**기록까지 남아있다는 점에서 아주 좋은 방법이라고 생각했습니다! 👍**\n"},{"excerpt":"해당 글은 우아한테크코스 5기 팀바팀 크루 성하가 작성했습니다! 📘 0. 일정 등록 API Request Body API 명세를 정할 당시에는 LocalDateTime이 요청으로 들어왔을 때 어떻게 Request Dto의 필드로 바인딩되는지 감이 안 잡혔습니다. 그래서 우선 API 명세를 확정한 이후에 부딪혀보자! 라고 마음을 다잡고 명세를 정했었습니다.…","fields":{"slug":"/local-date-time-binding/"},"frontmatter":{"date":"July 01, 2023","title":"LocalDateTime 원하는 Format으로 바인딩하기 (feat.@DateTimeFormat, @JsonFormat)","tags":["Spring","LocalDateTime"]},"rawMarkdownBody":"\n> 해당 글은 우아한테크코스 5기 팀바팀 크루 [성하](https://github.com/sh111-coder)가 작성했습니다!\n\n\n## 📘 0. 일정 등록 API Request Body\nAPI 명세를 정할 당시에는\n\nLocalDateTime이 요청으로 들어왔을 때 어떻게 Request Dto의 필드로 바인딩되는지 감이 안 잡혔습니다.\n\n\n\n그래서 우선 API 명세를 확정한 이후에 부딪혀보자! 라고 마음을 다잡고 명세를 정했었습니다.\n\n\n\n그렇게 일정 등록 API 명세가 확정된 채로, 일정 등록 API를 구현하게 됐습니다.\n\n\n\n확정된 일정 등록 API의 Request Body는 다음과 같았습니다.\n```http request\n{\n    \"title\": \"4차 데모데이 회의 (아무것도 구현안함)\",\n    \"startDateTime\": \"2023-07-13 14:00\",\n    \"endDateTime\": \"2023-07-14 15:59\"\n}\n```\nstartDateTime과 endDateTime을 LocalDateTime으로 바인딩할 때 공부한 내용을 공유하겠습니다! ✌🏻\n\n\n## ❌ 1. 문제 상황\n\nRequest로 오는 String의 날짜 형식을 LocalDateTime에 어떻게 바인딩할지 찾아보니,\n\n\n\n@DateTimeFormat을 사용하여 Request Dto 필드의 형식을 지정할 수 있었습니다.\n\n\n그래서 다음과 같이 Request Dto를 생성하였습니다.\n\n```java\npublic record ScheduleRegisterRequest(\n\n        @NotBlank(message = \"제목은 빈 값일 수 없습니다.\")\n        String title,\n\n        @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm\")\n        LocalDateTime startDateTime,\n\n        @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm\")\n        LocalDateTime endDateTime) {\n\n}\n```\n그 후, 객체가 잘 바인딩이 되는지 API 테스트를 진행했습니다.\n\n결과는, 다음과 같이 에러가 발생했습니다.\n\n```java\njava.time.format.DateTimeParseException: Text '2023-07-13 14:00' could not be parsed at index 10\n\tat java.base/java.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:2052) ~[na:na]\n\tat java.base/java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:1954) ~[na:na]\n\tat java.base/java.time.LocalDateTime.parse(LocalDateTime.java:494) ~[na:na]\n\tat com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer._fromString(LocalDateTimeDeserializer.java:177) ~[jackson-datatype-jsr310-2.15.2.jar:2.15.2]\n\tat com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer.deserialize(LocalDateTimeDeserializer.java:81) ~[jackson-datatype-jsr310-2.15.2.jar:2.15.2]\n\tat com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer.deserialize(LocalDateTimeDeserializer.java:40) ~[jackson-datatype-jsr310-2.15.2.jar:2.15.2]\n    \n    ...\n```\n에러 로그를 보면, String으로 들어온 '2023-07-13 14:00' 데이터 바인딩 시 오류가 난 것을 확인할 수 있었습니다.\n\n\n\n## 🔮 2. @JsonFormat으로 해결\n결과적으로, **@DateTimeFormat** 대신 **@JsonFormat**을 사용하여 해결할 수 있었습니다.\n\n```java\npublic record ScheduleRegisterRequest(\n        @NotBlank(message = \"제목은 빈 값일 수 없습니다.\")\n        String title,\n\n        @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"yyyy-MM-dd HH:mm\", timezone = \"Asia/Seoul\")\n        LocalDateTime startDateTime,\n\n        @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"yyyy-MM-dd HH:mm\", timezone = \"Asia/Seoul\")\n        LocalDateTime endDateTime) {\n\n}\n```\n\n그렇다면, 왜 @DateTimeFormat 대신 @JsonFormat을 사용해야 했을까요?\n\n두 어노테이션을 간단히 살펴봅시다.\n\n\n## ✅ 3. @DateTimeFormat VS @JsonFormat\n\n먼저 @DateTimeFormat을 살펴보면 다음과 같습니다.\n\n```java\npackage org.springframework.format.annotation;\n\n...\n\npublic @interface DateTimeFormat {\n\t...\n}\n```\n패키지에서 볼 수 있듯이 **@DateTimeFormat**은 Spring의 어노테이션입니다.\n\n\n\n그럼, **@JsonFormat**을 살펴볼까요?\n```java\npackage com.fasterxml.jackson.annotation;\n\n...\n\npublic @interface JsonFormat {\n\t...\n}\n```\n패키지를 보면 **@JsonFormat**은 @RequestBody, @ResponseBody를 사용한 직렬화/역직렬화를 담당하는\n\nJackson 라이브러리의 어노테이션입니다.\n\n\n\nJackson 라이브러리에서는 내부적으로 pattern으로 지정한 형식을 LocalDateTime으로 변환해줍니다.\n\n따라서, Jackson 라이브러리의 @JsonFormat은 날짜 형식이라면 자유롭게 사용이 가능합니다.\n\n\n\n하지만, @RequestBody, @ResponseBody를 사용한 역직렬화/직렬화 시\n\n@DateTimeFormat을 사용하려면 Jackson 라이브러리에 있는 어노테이션이 아니기 때문에\n\nLocalDateTime의 기본 형식인 'yyyy-MM-dd'T'HH:mm:ss'으로 요청이 들어와야 바인딩됩니다.\n\n(이때, @DateTimeFormat을 사용하지 않아도 바인딩이 됩니다.)\n\n\n## ❓ 4. @RequestParam, @ModelAttribute에서는 무엇을 사용해야 할까?\n위에서 설명한 상황은 @RequestBody, @ResponseBody 등\n\nJackson 라이브러리를 사용하여 역직렬화/직렬화를 하는 상황이었습니다.\n\n\n그렇다면, Jackson 라이브러리가 관여하지 않는 @RequestParam, @ModelAttribute에서는 무엇을 사용해야 할까요?\n\n\nJackson 라이브러리가 사용되지 않기 때문에 **@JsonFormat은 무시되게 됩니다.**\n\n**따라서, @DateTimeFormat을 사용하여 날짜 형식을 자유롭게 바인딩 할 수 있습니다.**\n\n\n## 🎯 5. 결론\n\n따라서, 결론적으로 @RequestBody, @ResponseBody를 사용한 역직렬화/직렬화 시\n\n날짜 형식을 자유롭게 사용하기 위해서는\n\n**@DateTimeFormat이 아닌, @JsonFormat을 사용해야합니다.**\n\n@RequestBody, @ResponseBody를 사용한 역직렬화/직렬화 시에 Jackson 라이브러리를 사용하여 날짜를 변환하기 때문에,\n\n**Jackson 라이브러리의 어노테이션인 @JsonFormat**을 사용해야 함을 알 수 있었습니다.\n\n(물론, Request Body 날짜 형식이 LocalDateTime의 기본 형식인  'yyyy-MM-dd'T'HH:mm:ss'이라면\n\n@DateTimeFormat, @JsonFormat 둘다 사용하지 않아도 그대로 바인딩이 가능합니다.)\n\n반대로, Jackson 라이브러리가 사용되지 않는\n\n@RequestBody, @ResponseBody의 경우에는 @DateTimeFormat을 사용해야 함을 알 수 있었습니다.\n\n위의 결론을 요약하면 다음과 같습니다!\n\n```java\n* 기본 전제 : LocalDateTime의 기본 형식인 'yyyy-MM-dd'T'HH:mm:ss'이 아닐 때\n\n1. @RequestBody, @ResponseBody : @JsonFormat 사용\n2. @RequestParam, @ModelAttribute : @DateTimeFormat 사용\n```\n\n\n---\n\n#### Reference\n[Controller 메서드에서 LocalDateTime 타입의 변수 바인딩 받기](https://swampwar.github.io/2020/03/19/LocalDateTime-%EB%B3%80%EC%88%98%EB%B0%94%EC%9D%B8%EB%94%A9.html)\n[SpringBoot에서 날짜 타입 JSON 변환에 대한 오해 풀기](https://jojoldu.tistory.com/361)\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}